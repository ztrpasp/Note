## shell

### 常见指令

* echo
* date
* $PATH
  * 环境变量的路径
* cat
* cd

```shell
cd - //切换到你之前所在的目录
```

* ls

在使用指令时，有很多的flags和arguements可以使用，通常以`-`开头

例如`--help` 

* 权限问题 `ls -l` or `ll`
* mv
  * 可以重命名一个文件，例如 `mv text.md my.md`
  * 可以移动文件
* cp
* rm
  * rm 默认不是递归删除，如果想要删除一个目录使用 `-r`来进行递归删除
  * `-f`指令即使原档案属性设为唯读，亦直接删除，无需逐一确认。
* mkdir
* man

即manus pages，它以其他的指令名作为输入，如`man ls`与`ls --help`效果类似。

----

### 输入流和输出流

重定向输入流与输出流，使用 `< >` angle bracket signs

`<` 表示将这个程序的输入重定向为这个文件的内容

`>` 表示将前面程序的输出层重定向到这个文件中

```shell
echo hello > hello.txt //会创建一个hello.txt的文件

cat hello.txt

cat < hello.txt  //

cat < hello.txt > hello2.txt // 实现了类似 cp的操作
```



`>`表示写入，但`>>`表示追加



> 管道符 `|`

==将左边程序的输出作为右边程序的输入==



```
ls -l | 
```

-------------------

### grep

Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。

grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **-**，则 grep 指令会从标准输入设备读取数据。

语法

```
grep [options] pattern [files]
或
grep [-abcEFGhHilLnqrsvVwxy][-A<显示行数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]
```

- pattern - 表示要查找的字符串或正则表达式。
- files - 表示要查找的文件名，可以同时查找多个文件，如果省略 files 参数，则默认从标准输入中读取数据。

**常用选项：**：

- `-i`：忽略大小写进行匹配。
- `-v`：反向查找，只打印不匹配的行。
- `-n`：显示匹配行的行号。
- `-r`：递归查找子目录中的文件。
- `-l`：只打印匹配的文件名。
- `-c`：只打印匹配的行数。



==ripgrep是开源社区正在进行的 RIIR（用 [Rust](https://zhida.zhihu.com/search?content_id=200992856&content_type=Article&match_order=1&q=Rust&zhida_source=entity) 重写）努力的一个优秀成果。，它旨在成为经典grep 命令的高级替代品。==

使用 ripgrep 的语法如下：

```text
rg <pattern> [files/directories]
```

使用 ripgrep，无需提及文件名。如果未提供文件名，则搜索所有文件，如果您不知道哪个文件包含您搜索的模式，这将非常有用。



--------

### more interesting

`sudo` 超级用户



当我们访问内核的文件时，需要root或者超级用户的权限，想当然的

```shell
sudo echo 500 > /sys/intel/brightness
//但是结果是permission denied
//因为 > 的重定向是shell来做的，sudo命令是sudo echo。写入brightness文件是shell做的，shell本身并没有超级用户权限
```

解决办法：

1. ==`sudo su`  以超级用户身份获得一个`shell`==

2. ``` shell
   echo 1060 | sudo tee brightness
   ```



> tee
>
> tee命令在Linux中用于从标准输入读取数据，并将其写入到标准输出和一个或多个文件中。tee命令通常与其他命令一起通过管道使用。
>
> `tee [OPTIONS] [FILE]`
>
> -a, --append	不覆盖文件，而是将输出追加到给定的文件中



-----------------



## shell工具和脚本

### 变量的定义 

`foo=bar`

变量的访问，使用`$`，例如`echo $foo`



字符串

单引号

```
str='this is a string'
```

单引号字符串的限制：

- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
- 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

双引号



```shell
your_name="runoob"
str="Hello, I know you are $your_name"
```

输出结果为：

```
Hello, I know you are "runoob"! 
```

双引号的优点：

- 双引号里可以有变量
- 双引号里可以出现转义字符

-------

### Shell 传递参数

我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为 **$n**，**n** 代表一个数字，**1** 为执行脚本的第一个参数，**2** 为执行脚本的第二个参数。

例如可以使用 **$1、$2** 等来引用传递给脚本的参数，其中 **$1** 表示第一个参数，**$2** 表示第二个参数，依此类推。



另外，还有几个特殊字符用来处理参数：

| 参数处理 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| $#       | 传递到脚本的参数个数                                         |
| $*       | 以一个单字符串显示所有向脚本传递的参数。 如"\$"用「"」括起来的情况、以"\$1 \$2 … $n"的形式输出所有参数。 |
| $$       | 脚本运行的当前进程ID号                                       |
| $!       | 后台运行的最后一个进程的ID号                                 |
| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
| $-       | 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。 |
| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |
| $0       | 该bash文件名                                                 |



`!!`表示上一次执行的指令



### 标准重定向与错误重定向

```shell
>
2>
```



------------

### 检查shell脚本

`shellcheck`



----

### 工具-tldr

==tldr== 

==`TLDR` (Too Long; Didn’t Read) 是一个由社区维护的帮助页面集合, 相较于传统的使用手册, TLDR 旨在以更简单, 更易理解的方式为命令提供说明, 对于命令行新手十分友好==



### 查找文件

`find`	



### 历史指令

* `history` 会打印所有的bash指令
* 可以使用管道和grep处理输出，例如 `history | grep cd` 则会打印所有含有cd的指令
* 或者 `ctrl+r`反向搜索



### 模糊查找

`fzf`



### 目录和文件列表

`tree`

`broot`

--------------

## vim

Vim 的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：

- **正常模式**：在文件中四处移动光标进行修改
- **插入模式**：插入文本
- **替换模式**：替换文本
- **可视化模式**（一般，行，块）：选中文本块
- **命令模式**：用于执行命令

在不同的操作模式下，键盘敲击的含义也不同。比如，`x` 在插入模式会插入字母 `x`，但是在正常模式
会删除当前光标所在的字母，在可视模式下则会删除选中文块。

在默认设置下，Vim 会在左下角显示当前的模式。Vim 启动时的默认模式是正常模式。通常你会把大部分
时间花在正常模式和插入模式。

你可以按下 `<ESC>`（退出键）从任何其他模式返回正常模式。在正常模式，键入 `i` 进入插入
模式，`R` 进入替换模式，`v` 进入可视（一般）模式，`V` 进入可视（行）模式，`<C-v>`
（Ctrl-V, 有时也写作 `^V`）进入可视（块）模式，`:` 进入命令模式。

因为你会在使用 Vim 时大量使用 `<ESC>` 键，所以可以考虑把大小写锁定键重定义成 `<ESC>` 键（[MacOS 教程](https://vim.fandom.com/wiki/Map_caps_lock_to_escape_in_macOS)）。

### 缓存， 标签页， 窗口

Vim 会维护一系列打开的文件，称为“缓存”（buffer）。

==一个 Vim 会话包含一系列标签页（tab），每个标签页包含一系列窗口（window）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是，缓存和窗口不是一一对应的关系；窗口只是缓冲区的视图。一个缓存可以在 *多个* 窗口打开，甚至在同一个标签页内的多个窗口打开。这个功能其实很好用，比如可以查看同一个文件的不同部分。==

Vim 默认打开一个标签页，这个标签也包含一个窗口。



`:q`命令的作用是关闭一个窗口，当前若只有一个窗口，他就会退出vim







基本上 vi/vim 共分为三种模式，**命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）**。

### 命令模式

**用户刚刚启动 vi/vim，便进入了命令模式。**

此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符，比如我们此时按下 **i**，并不会输入一个字符，**i** 被当作了一个命令。

以下是普通模式常用的几个命令：

- **i** -- 切换到输入模式，在光标当前位置开始输入文本。
- **x** -- 删除当前光标所在处的字符。
- **:** -- 切换到底线命令模式，以在最底一行输入命令。
- **a** -- 进入插入模式，在光标下一个位置开始输入文本。
- **o**：在当前行的下方插入一个新行，并进入插入模式。
- **O** -- 在当前行的上方插入一个新行，并进入插入模式。
- **dd** -- 剪切当前行。
- **yy** -- 复制当前行。
- **p**（小写） -- 粘贴剪贴板内容到光标下方。
- **P**（大写）-- 粘贴剪贴板内容到光标上方。
- **u** -- 撤销上一次操作。
- **Ctrl + r** -- 重做上一次撤销的操作。
- **:w** -- 保存文件。
- **:q** -- 退出 Vim 编辑器。
- **:q!** -- 强制退出Vim 编辑器，不保存修改。

### 修饰语

你可以用修饰语改变“名词”的意义。修饰语有 `i`，表示“内部”或者“在内”，和 `a`，
表示“周围”。

- `ci(` 改变当前括号内的内容
- `ci[` 改变当前方括号内的内容
- `da'` 删除一个单引号字符串， 包括周围的单引号

### 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等

| 移动光标的方法                                               |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| ==h 或 向左箭头键(←)==                                       | ==光标向左移动一个字符==                                     |
| ==j 或 向下箭头键(↓)==                                       | ==光标向下移动一个字符==                                     |
| ==k 或 向上箭头键(↑)==                                       | ==光标向上移动一个字符==                                     |
| ==l 或 向右箭头键(→)==                                       | 光标向右移动一个字符                                         |
| 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ |                                                              |
| ==[Ctrl] + [d]==                                             | ==屏幕『向下』移动半页==                                     |
| ==[Ctrl] + [u]==                                             | ==屏幕『向上』移动半页==                                     |
| +                                                            | 光标移动到非空格符的下一行                                   |
| -                                                            | 光标移动到非空格符的上一行                                   |
| n<space>                                                     | 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。 |
| ==0 或功能键[Home]==                                         | ==这是数字『 0 』：移动到这一行的最前面字符处 (常用)==       |
| ==$ 或功能键[End]==                                          | ==移动到这一行的最后面字符处(常用)==                         |
| H                                                            | 光标移动到这个屏幕的最上方那一行的第一个字符                 |
| M                                                            | 光标移动到这个屏幕的中央那一行的第一个字符                   |
| L                                                            | 光标移动到这个屏幕的最下方那一行的第一个字符                 |
| ==G==                                                        | 移动到这个档案的最后一行(常用)                               |
| nG                                                           | n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) |
| ==gg==                                                       | 移动到这个档案的第一行，相当于 1G 啊！ (常用)                |
| n<Enter>                                                     | n 为数字。光标向下移动 n 行(常用)                            |





| 搜索替换                                      |                                                              |
| :-------------------------------------------- | ------------------------------------------------------------ |
| /word                                         | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) |
| ?word                                         | 向光标之上寻找一个字符串名称为 word 的字符串。               |
| n                                             | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |
| N                                             | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |
| `f{字符}`， `t{字符}`， `F{字符}`， `T{字符}` | 查找/到 向前/向后 在本行的{字符} `,` / `;` 用于导航匹配      |



| 删除、复制与贴上 |                                                              |
| :--------------- | ------------------------------------------------------------ |
| x, X             | 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) |
| nx               | n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 |
| ==dd==           | ==剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。==          |
| ==ndd==          | ==n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。== |
| d1G              | 删除光标所在到第一行的所有数据                               |
| dG               | 删除光标所在到最后一行的所有数据                             |
| ==d$==           | ==删除游标所在处，到该行的最后一个字符==                     |
| ==d0==           | ==那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符==  |
| ==yy==           | ==复制游标所在的那一行(常用)==                               |
| ==nyy==          | ==n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)== |
| y1G              | 复制游标所在行到第一行的所有数据                             |
| yG               | 复制游标所在行到最后一行的所有数据                           |
| ==y0==           | ==复制光标所在的那个字符到该行行首的所有数据==               |
| ==y$==           | ==复制光标所在的那个字符到该行行尾的所有数据==               |
| ==p, P==         | ==p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)== |
| J                | 将光标所在行与下一行的数据结合成同一行                       |
| ==c==            | ==重复删除多个数据，例如向下删除 10 行，[ 10cj ]==           |
| ==u==            | ==复原前一个动作。(常用)==                                   |
| ==[Ctrl]+r==     | ==重做上一个动作。(常用)==                                   |



打开多个文件：

一、vim还没有启动的时候：

1.在终端里输入 

vim file1 file2 ... filen便可以打开所有想要打开的文件

2.vim已经启动

输入

:e file

可以再打开一个文件，并且此时vim里会显示出file文件的内容。

3.同时显示多个文件：

:sp     //水平切分窗口

:vsplit   //垂直切分窗口

二、在文件之间切换：

1.文件间切换

Ctrl+6  //两文件间的切换

:bn    //下一个文件

:bp    //上一个文件
:ls    //列出打开的文件，带编号
:b1~n  //切换至第n个文件

对于用(v)split在多个窗格中打开的文件，这种方法只会在当前窗格中切换不同的文件。

2.在窗格间切换的方法

Ctrl+w+方向键——切换到前／下／上／后一个窗格

Ctrl+w+h/j/k/l ——同上

Ctrl+ww——依次向后切换到下一个窗格中



## 数据整理

正则表达式学习



## 命令行环境

### tmux

当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。

像 [`tmux`](https://www.man7.org/linux/man-pages/man1/tmux.1.html) 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。

不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。

这让您操作远端设备时的工作流大大改善，避免了 `nohup` 和其他类似技巧的使用。

现在最流行的终端多路器是 [`tmux`](https://www.man7.org/linux/man-pages/man1/tmux.1.html)。`tmux` 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。

`tmux` 的快捷键需要我们掌握，它们都是类似 `<C-b> x` 这样的组合，即需要先按下 `Ctrl+b`，松开后再按下 `x`。`tmux` 中对象的继承结构如下：

-   **会话** - 每个会话都是一个独立的工作区，其中包含一个或多个窗口
    -   `tmux` 开始一个新的会话
    -   `tmux new -s NAME` 以指定名称开始一个新的会话
    -   `tmux ls` 列出当前所有会话
    -   在 `tmux` 中输入 `<C-b> d` ，将当前会话分离
    -   `tmux a` 重新连接最后一个会话。您也可以通过 `-t` 来指定具体的会话

-   **窗口** - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分
    -   `<C-b> c` 创建一个新的窗口，使用 `<C-d>` 关闭
    -   `<C-b> N` 跳转到第 _N_ 个窗口，注意每个窗口都是有编号的
    -   `<C-b> p` 切换到前一个窗口
    -   `<C-b> n` 切换到下一个窗口
    -   `<C-b> ,` 重命名当前窗口
    -   `<C-b> w` 列出当前所有窗口

-   **面板** - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell
    -   `<C-b> "` 水平分割
    -   `<C-b> %` 垂直分割
    -   `<C-b> <方向>` 切换到指定方向的面板，<方向> 指的是键盘上的方向键
    -   `<C-b> z` 切换当前面板的缩放
    -   `<C-b> [` 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分
    -   `<C-b> <空格>` 在不同的面板排布间切换

`exit`退出tmux

扩展阅读：
[这里](https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/) 是一份 `tmux` 快速入门教程， [而这一篇](http://linuxcommand.org/lc3_adv_termmux.php) 文章则更加详细，它包含了 `screen` 命令。您也许想要掌握 [`screen`](https://www.man7.org/linux/man-pages/man1/screen.1.html) 命令，因为在大多数 UNIX 系统中都默认安装有该程序。

tumx 用来将会话(session)与窗口分离，可以看作是包含关系，其中一个session可以分为多个窗口，一个窗口可以分为多个pane。类似于树形继承

### vim

vim每个文件有一个buffer，一个窗口对应一个buffer，一个buffer可以有多个窗口。

tab 标签

### 配置文件（Dotfiles)

很多程序的配置都是通过纯文本格式的被称作 _点文件_ 的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 `.` 开头，例如 `~/.vimrc`。也正因为此，它们默认是隐藏文件，`ls` 并不会显示它们）。

shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，[这里](https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html) 有非常好的资源

对于 `bash` 来说，在大多数系统下，您可以通过编辑 `.bashrc` 或 `.bash_profile` 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。

实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 `export PATH="$PATH:/path/to/program/bin"` 的命令，这样才能确保这些程序能够被 shell 找到。

还有一些其他的工具也可以通过 _点文件_ 进行配置：

-   `bash` - `~/.bashrc`, `~/.bash_profile`
-   `git` - `~/.gitconfig`
-   `vim` - `~/.vimrc` 和 `~/.vim` 目录
-   `ssh` - `~/.ssh/config`
-   `tmux` - `~/.tmux.conf`

我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 **符号链接** 到需要的地方。这么做有如下好处：

-   **安装简单**: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；
-   **可移植性**: 您的工具在任何地方都以相同的配置工作
-   **同步**: 在一处更新配置文件，可以同步到其他所有地方
-   **变更追踪**: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的

配置文件中需要放些什么？您可以通过在线文档和 [帮助手册](https://en.wikipedia.org/wiki/Man_page) 了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的 [dotfiles 仓库](https://github.com/search?o=desc&q=dotfiles&s=stars&type=Repositories) —— 其中最受欢迎的那些可以在 [这里](https://github.com/mathiasbynens/dotfiles) 找到（我们建议您不要直接复制别人的配置）。[这里](https://dotfiles.github.io/) 也有一些非常有用的资源。

本课程的老师们也在 GitHub 上开源了他们的配置文件：
[Anish](https://github.com/anishathalye/dotfiles),
[Jon](https://github.com/jonhoo/configs),
[Jose](https://github.com/jjgo/dotfiles),























## 后续

[课程链接](https://github.com/missing-semester-cn/missing-semester-cn.github.io)

后续笔记missing-semester-mit文件夹中







